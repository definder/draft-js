<!--
Copyright (c) 2013-present, Facebook, Inc. All rights reserved.

This file provided by Facebook is for non-commercial testing and evaluation
purposes only. Facebook reserves all rights not expressly granted.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Draft â€¢ Rich Text</title>
  <link rel="stylesheet" href="../../dist/Draft.css"/>
  <link rel="stylesheet" href="RichEditor.css"/>
  <style>
    #target {
      width: 600px;
    }
  </style>
</head>
<body>
<div id="target"></div>
<script src="../../node_modules/react/dist/react.js"></script>
<script src="../../node_modules/react-dom/dist/react-dom.js"></script>
<script src="../../node_modules/immutable/dist/immutable.js"></script>
<script src="../../node_modules/es6-shim/es6-shim.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.js"></script>
<script src="../../dist/Draft.js"></script>
<script type="text/babel">
  'use strict';

  const {Editor, EditorState, RichUtils, genKey, BlockMapBuilder, Modifier, CharacterMetadata, ContentBlock} = Draft;

  class RichEditorExample extends React.Component {
    constructor(props) {

      super(props);
      this.state = {editorState: EditorState.createEmpty(), disabled: false};

      this.focus = () => {
        this.setState({disabled: false}, () => this.refs.editor.focus())
      };
      this.onChange = (editorState) => this.setState({editorState});

      this.handleKeyCommand = (command) => this._handleKeyCommand(command);
      this.onTab = (e) => this._onTab(e);
      this.toggleBlockType = (type) => this._toggleBlockType(type);
      this.toggleInlineStyle = (style) => this._toggleInlineStyle(style);
      this.addReplaceAtom = (data) => {
        if (!data) {
          let editorState = this.state.editorState
          let contentState = editorState.getCurrentContent();
          const contentStateWithEntity = contentState.createEntity(
            'TEST',
            'IMMUTABLE',
            {count: 0},
          )
          const entityKey = contentStateWithEntity.getLastCreatedEntityKey();
          const newEditorState = EditorState.set(
            editorState,
            {currentContent: contentStateWithEntity},
          )


          contentState = newEditorState.getCurrentContent()
          let selectionState = editorState.getSelection()

          let afterRemoval = Modifier.removeRange(contentState, selectionState, 'backward')

          let targetSelection = afterRemoval.getSelectionAfter()
          let afterSplit = Modifier.splitBlock(afterRemoval, targetSelection)
          let insertionTarget = afterSplit.getSelectionAfter()

          let asAtomicBlock = Modifier.setBlockType(afterSplit, insertionTarget, 'atom')

          let charData = CharacterMetadata.create({entity: entityKey})
          let fragmentArray = [new ContentBlock({
            key: genKey(),
            type: 'atomic',
            text: ' ',
            characterList: Immutable.List(Immutable.Repeat(charData, 1))
          }), new ContentBlock({
            key: genKey(),
            type: 'unstyled',
            text: '',
            characterList: Immutable.List()
          })]

          let fragment = BlockMapBuilder.createFromArray(fragmentArray)

          let withAtomicBlock = Modifier.replaceWithFragment(asAtomicBlock, insertionTarget, fragment)

          let newContent = withAtomicBlock.merge({
            selectionBefore: selectionState,
            selectionAfter: withAtomicBlock.getSelectionAfter().set('hasFocus', true)
          })
          this.setState({editorState: EditorState.push(editorState, newContent, 'insert-fragment')});
        }
      };
      this.publicMethods = () => {
        return {
            setEditorState: this.onChange,
            getEditorState: () => this.state.editorState,
        }
      }
    }

    _handleKeyCommand(command) {
      const {editorState} = this.state;
      const newState = RichUtils.handleKeyCommand(editorState, command);
      if (newState) {
        this.onChange(newState);
        return true;
      }
      return false;
    }

    _onTab(e) {
      const maxDepth = 4;
      this.onChange(RichUtils.onTab(e, this.state.editorState, maxDepth));
    }

    _toggleBlockType(blockType) {
      this.onChange(
        RichUtils.toggleBlockType(
          this.state.editorState,
          blockType
        )
      );
    }

    _toggleInlineStyle(inlineStyle) {
      this.onChange(
        RichUtils.toggleInlineStyle(
          this.state.editorState,
          inlineStyle
        )
      );
    }

    render() {
      const {editorState} = this.state;

      // If the user changes block type before entering any text, we can
      // either style the placeholder or hide it. Let's just hide it now.
      let className = 'RichEditor-editor';
      var contentState = editorState.getCurrentContent();
      if (!contentState.hasText()) {
        if (contentState.getBlockMap().first().getType() !== 'unstyled') {
          className += ' RichEditor-hidePlaceholder';
        }
      }

      return (
        <div className="RichEditor-root">
          <BlockStyleControls
            editorState={editorState}
            onToggle={this.toggleBlockType}
          />
          <InlineStyleControls
            editorState={editorState}
            onToggle={this.toggleInlineStyle}
            addTestAtom={this.addReplaceAtom}
          />
          <div className={className} onClick={this.focus}>
            <Editor
              blockStyleFn={getBlockStyle}
              blockRendererFn={(block) => {
                if(block.getType() === 'atomic'){
                  const entityKey = block.getEntityAt(0)
                  if(entityKey){
                    const contentState = this.state.editorState.getCurrentContent()
                    const entity = contentState.getEntity(block.getEntityAt(0))
                    if (entity.getType() === 'TEST') {
                      return ({
                        component: TestAtomComponent,
                        editable: false,
                        props: {
                          data: entity.getData(),
                          updateTestAtom: (key, data) => {
                            const contentState = this.state.editorState.getCurrentContent();
                            const entityKey = contentState.getBlockForKey(key).getEntityAt(0);
                            const newContentState = contentState.replaceEntityData(entityKey, data);
                            console.log('Equiel', newContentState === contentState)
                            this.setState({
                              editorState:
                              EditorState.push(this.state.editorState, newContentState, 'undo')
                            })
                          }
                        }
                      })
                    }
                  }
                  return false
                }
                return false
              }}
              customStyleMap={styleMap}
              editorState={editorState}
              handleKeyCommand={this.handleKeyCommand}
              onChange={this.onChange}
              onTab={this.onTab}
              placeholder="Tell a story..."
              ref="editor"
              spellCheck={true}
              nameOffsetKey="data-neighbor-offset-key"
              disabledHandlers={this.state.disabled}
            />
          </div>
        </div>
      );
    }
  }

  class TestAtomComponent extends React.PureComponent {

    render() {
      const {
        blockProps: {
          data,
          updateTestAtom,
        },
      } = this.props
      return (
        <div style={{width: '100%', padding: '10px 0'}}>
          <h1>{data.count}</h1>
          <a onClick={(event) => {
            updateTestAtom(this.props.block.getKey(), {count: data.count + 1});
            event.preventDefault();
            event.stopPropagation();
            return false;
          }} href="/" >Increment</a>
        </div>
      );
    }

  }

  // Custom overrides for "code" style.
  const styleMap = {
    CODE: {
      backgroundColor: 'rgba(0, 0, 0, 0.05)',
      fontFamily: '"Inconsolata", "Menlo", "Consolas", monospace',
      fontSize: 16,
      padding: 2,
    },
  };

  function getBlockStyle(block) {
    switch (block.getType()) {
      case 'blockquote':
        return 'RichEditor-blockquote';
      default:
        return null;
    }
  }

  class StyleButton extends React.Component {
    constructor() {
      super();
      this.onToggle = (e) => {
        e.preventDefault();
        this.props.onToggle(this.props.style);
      };
    }

    render() {
      let className = 'RichEditor-styleButton';
      if (this.props.active) {
        className += ' RichEditor-activeButton';
      }

      return (
        <span className={className} onMouseDown={this.onToggle}>
              {this.props.label}
            </span>
      );
    }
  }

  const TestAtom = ({text, onToggle}) => {
    let className = 'RichEditor-styleButton';
    return (
      <span className={className} onClick={() => {
        onToggle()
      }}>
            {text}
          </span>
    );
  }

  const BLOCK_TYPES = [
    {label: 'H1', style: 'header-one'},
    {label: 'H2', style: 'header-two'},
    {label: 'H3', style: 'header-three'},
    {label: 'H4', style: 'header-four'},
    {label: 'H5', style: 'header-five'},
    {label: 'H6', style: 'header-six'},
    {label: 'Blockquote', style: 'blockquote'},
    {label: 'UL', style: 'unordered-list-item'},
    {label: 'OL', style: 'ordered-list-item'},
    {label: 'Code Block', style: 'code-block'},
  ];

  const BlockStyleControls = (props) => {
    const {editorState} = props;
    const selection = editorState.getSelection();
    const blockType = editorState
      .getCurrentContent()
      .getBlockForKey(selection.getStartKey())
      .getType();

    return (
      <div className="RichEditor-controls">
        {BLOCK_TYPES.map((type) =>
          <StyleButton
            key={type.label}
            active={type.style === blockType}
            label={type.label}
            onToggle={props.onToggle}
            style={type.style}
          />
        )}
      </div>
    );
  };

  var INLINE_STYLES = [
    {label: 'Bold', style: 'BOLD'},
    {label: 'Italic', style: 'ITALIC'},
    {label: 'Underline', style: 'UNDERLINE'},
    {label: 'Monospace', style: 'CODE'},
  ];

  const addTestAtom = () => {

  }

  const InlineStyleControls = (props) => {
    var currentStyle = props.editorState.getCurrentInlineStyle();
    return (
      <div className="RichEditor-controls">
        {INLINE_STYLES.map(type =>
          <StyleButton
            key={type.label}
            active={currentStyle.has(type.style)}
            label={type.label}
            onToggle={props.onToggle}
            style={type.style}
          />
        )}
        <TestAtom
          text="TEST"
          onToggle={props.addTestAtom}
          style={'TEST'}
        />
      </div>
    );
  };

  ReactDOM.render(
    <RichEditorExample />,
    document.getElementById('target')
  );
</script>
</body>
</html>
